---
description: Signed receipts provide proof of time
---

import { Callout } from "nextra-theme-docs";

# Receipts

Receipts give you cryptographic proof of the exact time, accurate to the millisecond, that a transaction was posted.

## Receipts & Timestamps

When you upload data to Irys, it is stamped with a millisecond-accurate timestamp before being stored onchain.

Blockchains rely on timestamps to sequence the order of transactions and blocks. Transaction sequencing plays a critical role in blockchain security as it ensures that all transactions are recorded in the correct order, and that order is never changed.

Receipts provide cryptographic proof of a timestamp.

## Ordering & Streaming

Ordering and streaming applications process and deliver data in real-time. They're commonly used for messaging, event processing, and data integration. They transfer high data volumes between independent applications while maintaining high performance and scalability. Popular examples include Apache Kafka and RabbitMQ.

Users could use Irys's receipts to:

- Build a category-based event streaming application using [GraphQL](/build/d/graphql)

## Why Use Signed Receipts?

Cryptographically signed receipts open up new development options for builders. For example:

1. Sequential ordering of posts, likes and comments for a decentralized social protocol.
2. Sequential ordering of data generated by a group messaging protocol.
3. Automatically adjudicating music copyright claims.
4. Preserving history, ensuring it's not manipulated over time.
5. Preserving scientific research using Irys's pay-once, store-forever model.

## Receipt Permanence

Upon posting a transaction to Irys, a receipt is immediately returned to the user.

Irys maintains an internal registry of all receipts, [which can be queried whenever a receipt is needed](/build/d/sdk/api/utils-getReceipt). These receipts are stored in a centralized fashion, which may be sufficient for users comfortable with the trust assumptions of centralized services.

Users also have the option to permanently store the receipt on on Irys.

## Receipt format

Receipts are a JSON object with the following format:

```json
{
  id: '1Txlbl5NgEqUbIkDnnunHC0gFx0n8_Y92zAsoX54kI8',
  timestamp: 1676891681110,
  version: '1.0.0',
  public: '...',
  signature: '...',
  deadlineHeight: ...,
  block: ...,
  validatorSignatures: [],
}
```

| Field               | Description                                                            |
| ------------------- | ---------------------------------------------------------------------- |
| ID                  | Transaction ID (used to download the data)                             |
| timestamp           | Timestamp (UNIX milliseconds) of when the transaction was created      |
| version             | The version of this JSON file, currently 1.0.0                         |
| public              | Public key of the bundler node used                                    |
| signature           | A signed deep hash of the JSON receipt                                 |
| deadlineHeight      | The block number by which the transaction must be finalized            |
| block               | Deprecated                                                             |
| validatorSignatures | Deprecated                                                             |

### Verifying Receipts

You may need to [verify a receipt](/build/d/sdk/api/utils-verifyReceipt) at some point after it was issued. For example, if your applicationâ€™s security depends on the order of transactions, you can then verify every receipt to ensure its order has not been tampered with.

The receipt contains a signature field, which is generated by creating a deep hash of information from the receipt, including transaction ID and timestamp. The receipt is then signed it by Irys.

Using the [Irys SDK you can verify](/build/d/sdk/api/utils-verifyReceipt) the signature using the using the same values from the receipt along with the supplied public key.

## Timestamp Generation

Irys records the precise time of each transaction with a UNIX timestamp in milliseconds. This timestamp is generated by the node that first receives and verifies the transaction.
